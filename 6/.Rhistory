pathToFile <- "~/Desktop/S2017/StatisticalLearning/Exercises/2/Mean20.txt"
timeDelay <- read.table(pathToFile, header=T, colClasses = c('numeric'))
ctimeDelay <- na.omit(timeDelay)
ctimeDelay <- subset(ctimeDelay, ctimeDelay$time>0)
secondMinSquared <- function(x){
if(length(x)<=1){
print('Invalid input: should be a vector')
} else{
n <- length(x)
#m<-which(x==min(x))
#x<-x[-m]
#return(second_min <- min(x))
return (sort(x,partial=2)[2]^2)
}
}
secondMinSquared(ctimeDelay$time)
vecSummary <- function(x) {
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
} else {
x_summary <- c(mean(x),median(x), var(x), min(x), max(x))
return (x_summary);
}
}
vecSummary(c(1, 2, 2, 3)) #test with a normal array
vecSummary(ctimeDelay$time) #we apply it to our dataset of Mean20.txt so we can compare
vecSummary(1) # invalid input because we cannot compute variance
vecSummary('') # invalid input it should be numeric array or char array
vecSummary <- function(x) {
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
} else {
x_summary <- c(mean(x),median(x), var(x), min(x), max(x))
return (x_summary);
}
}
vecSummary(c(1, 2, 2, 3)) #test with a normal array
vecSummary(ctimeDelay$time) #we apply it to our dataset of Mean20.txt so we can compare
vecSummary(1) # invalid input because we cannot compute variance
vecSummary('') # invalid input it should be numeric array
vecSummary(c('a','b','c')) # invalid input should be a numeric array
pathToFile <- "~/Desktop/S2017/StatisticalLearning/Exercises/2/Mean20.txt"
timeDelay <- read.table(pathToFile, header=T, colClasses = c('numeric'))
ctimeDelay <- na.omit(timeDelay)
ctimeDelay <- subset(ctimeDelay, ctimeDelay$time>0)
secondMinSquared <- function(x){
if(length(x)<=1){
print('Invalid input: should be a vector')
} else{
n <- length(x)
#m<-which(x==min(x))
#x<-x[-m]
#return(second_min <- min(x))
return (sort(x,partial=2)[2]^2)
}
}
secondMinSquared('') # it should print an error message because it's not a vector
secondMinSquared(1) # it should also print error message
secondMinSquared(c(0)) # can't compute the second minimum because only one element in vector
secondMinSquared(c('a','b'))
secondMinSquared(c(1, 2, 1.3, 1.01, 4, 5)) #1.01
pathToFile <- "~/Desktop/S2017/StatisticalLearning/Exercises/2/Mean20.txt"
timeDelay <- read.table(pathToFile, header=T, colClasses = c('numeric'))
ctimeDelay <- na.omit(timeDelay)
ctimeDelay <- subset(ctimeDelay, ctimeDelay$time>0)
secondMinSquared <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
} else{
n <- length(x)
#m<-which(x==min(x))
#x<-x[-m]
#return(second_min <- min(x))
return (sort(x,partial=2)[2]^2)
}
}
secondMinSquared('') # it should print an error message because it's not a vector
secondMinSquared(1) # it should also print error message
secondMinSquared(c(0)) # can't compute the second minimum because only one element in vector
secondMinSquared(c('a','b'))
secondMinSquared(c(1, 2, 1.3, 1.01, 4, 5)) #1.01
secondMinSquared(ctimeDelay$time)
pathToFile <- "~/Desktop/S2017/StatisticalLearning/Exercises/2/Mean20.txt"
timeDelay <- read.table(pathToFile, header=T, colClasses = c('numeric'))
ctimeDelay <- na.omit(timeDelay)
ctimeDelay <- subset(ctimeDelay, ctimeDelay$time>0)
secondMinSquared(ctimeDelay$time)
secondMinSquared <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
} else{
n <- length(x)
#m<-which(x==min(x))
#x<-x[-m]
#return(second_min <- min(x))
return (sort(x,partial=2)[2]^2)
}
}
cars <- read.table('Cars2Data.txt', header = T)
cars <- carsData[-9]
null_cars.lm <- lm(mpg ~ 1, data=cars)
full_cars.lm <- lm(mpg ~ ., data=cars)
fwd_search <- step(null_cars.lm, scope=list(lower=null_cars.lm,
upper=full_cars.lm),direction="forward", trace=F)
cars <- read.table('Cars2Data.txt', header = T)
cars <- cars[-9]
cars <- na.omit(cars)
cars$origin <- as.factor(cars$origin)
summary(cars)
null_cars.lm <- lm(mpg ~ 1, data=cars)
full_cars.lm <- lm(mpg ~ ., data=cars)
fwd_search <- step(null_cars.lm, scope=list(lower=null_cars.lm,
upper=full_cars.lm),direction="forward", trace=F)
bckwd_search <- step(full_cars.lm, data=cars, direction="backward", trace = F)
summary(bckwd_search)
#start with all the descriptors of computer performance in the lm
summary.lm <- summary(lm(mpg ~ ., data=cars))
vars <- names(cars)
vars <- vars[which(vars != "mpg")]
tol <- 0.05
#while there are still variables with p-values larger than tol
while(length(which(summary.lm$coefficients[,4] > tol)) != 0){
#coefficients table
coef <- summary.lm$coefficients
#find the variable with the largest p-value
var_with_max_p.value <- rownames(coef)[apply(coef,2,which.max)][4]
#remove the variable with the larger value
vars <- vars[which(vars != var_with_max_p.value)]
#computer the model with the updated variables
lm2 <- lm(cars$mpg ~ ., data = cars[vars])
summary.lm <- summary(lm2)
}
summary.lm
cars.lm <- lm(mpg ~ cylinders + displacement + horsepower + weight +  year + origin,
data = cars)
par(mfrow=c(2,2))
plot(cars.lm)
title("LM model with step", line = -15, outer=TRUE)
cars_lm2 <- lm(mpg ~ weight + year + origin, data = cars)
par(mfrow=c(2,2))
plot(cars_lm2)
title("LM model with our method", line = -15, outer=TRUE)
cars.lm <- lm(mpg ~ cylinders + displacement + horsepower + weight +  year + origin,
data = cars)
par(mfrow=c(2,2))
plot(cars.lm)
title("LM model with step", line = -15, outer=TRUE)
cars_lm2 <- lm(mpg ~ displacement + horsepower + weight + year + origin, data = cars)
par(mfrow=c(2,2))
plot(cars_lm2)
title("LM model with our method", line = -15, outer=TRUE)
cars.lm <- lm(mpg ~ cylinders + displacement + horsepower + weight +  year + origin,
data = cars)
par(mfrow=c(2,2))
plot(cars.lm)
title("LM model with step", line = -15, outer=TRUE)
cars_lm2 <- lm(mpg ~ weight + year + origin, data = cars)
par(mfrow=c(2,2))
plot(cars_lm2)
title("LM model with our method", line = -15, outer=TRUE)
null_cars.lm <- lm(mpg ~ 1, data=cars)
full_cars.lm <- lm(mpg ~ ., data=cars)
fwd_search <- step(null_cars.lm, scope=list(lower=null_cars.lm,
upper=full_cars.lm),direction="forward", trace=F)
bckwd_search <- step(full_cars.lm, data=cars, direction="backward", trace = F)
summary(bckwd_search)
#start with all the descriptors of computer performance in the lm
summary.lm <- summary(lm(mpg ~ ., data=cars))
vars <- names(cars)
vars <- vars[which(vars != "mpg")]
tol <- 0.01
#while there are still variables with p-values larger than tol
while(length(which(summary.lm$coefficients[,4] > tol)) != 0){
#coefficients table
coef <- summary.lm$coefficients
#find the variable with the largest p-value
var_with_max_p.value <- rownames(coef)[apply(coef,2,which.max)][4]
#remove the variable with the larger value
vars <- vars[which(vars != var_with_max_p.value)]
#computer the model with the updated variables
lm2 <- lm(cars$mpg ~ ., data = cars[vars])
summary.lm <- summary(lm2)
}
summary.lm
cars.lm <- lm(mpg ~ cylinders + displacement + horsepower + weight +  year + origin,
data = cars)
par(mfrow=c(2,2))
plot(cars.lm)
title("LM model with step", line = -15, outer=TRUE)
cars_lm2 <- lm(mpg ~ weight + year + origin, data = cars)
par(mfrow=c(2,2))
plot(cars_lm2)
title("LM model with our method", line = -15, outer=TRUE)
cars <- read.table('Cars2Data.txt', header = T)
cars <- cars[-9]
cars <- na.omit(cars)
cars$origin <- as.factor(cars$origin)
summary(cars)
View(cars)
View(cars)
cars <- read.table('Cars2Data.txt', header = T)
t <- cars[,1:8]
cars <- cars[-9]
cars <- na.omit(cars)
cars$origin <- as.factor(cars$origin)
summary(cars)
View(t)
View(t)
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
}
return sqrt(sum(x^2)));
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
}
return sqrt(sum(x^2, na.rm = T)));
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
}
return sqrt(sum(x^2, na.rm = T)))
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
}
return sqrt( sum(x^2, na.rm = T))
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
}
return result <- sqrt( sum(x^2, na.rm = T))
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
}
return (distance <- sqrt( sum(x^2, na.rm = T)))
}
euclidian_distance(c(1,2,3))
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
}
return (distance <- sqrt( sum(x^2, na.rm = T)))
}
euclidian_distance(c(1,2,3))
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
}
return (distance <- sqrt( sum(x^2, na.rm = T)))
}
res <- euclidian_distance(c(1,2,3))
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
}
return (distance <- sqrt( sum(x^2, na.rm = T)))
}
res <- euclidian_distance(c(1,2,3))
res <- euclidian_distance(c(4,3,NA))
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
}
return (distance <- sqrt( sum(x^2, na.rm = T)))
}
res <- euclidian_distance(c(1,2,3)) # test with some random values
res1 <- euclidian_distance(c(4,3,NA)) # test with NA values in the vector
res2 <- euclidian_distance(c(-1,-2,-3)) #test with negative values
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
}
return (distance <- sqrt( sum(x^2, na.rm = T)))
}
res <- euclidian_distance(c(1,2,3)) # test with some random values
res1 <- euclidian_distance(c(4,3,NA)) # test with NA values in the vector
res2 <- euclidian_distance(c(-1,-2,-3)) # test with negative values
res3 <- euclidian_distance(c('1','b',3))
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
}
return (distance <- sqrt( sum(x^2, na.rm = T)))
}
res <- euclidian_distance(c(1,2,3)) # test with some random values
res1 <- euclidian_distance(c(4,3,NA)) # test with NA values in the vector
res2 <- euclidian_distance(c(-1,-2,-3)) # test with negative values
res3 <- euclidian_distance(c('b','b',3))
setwd("~/Desktop/S2017/StatisticalLearning/Exercises/6")
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) <= 1){
print('Invalid input: should be a numeric vector of length higher than 1')
return (NaN)
}
return (distance <- sqrt( sum(x^2, na.rm = T)))
}
res <- euclidian_distance(c(1,2,3)) # test with some random values
res1 <- euclidian_distance(c(4,3,NA)) # test with NA values in the vector
res2 <- euclidian_distance(c(-1,-2,-3)) # test with negative values
res3 <- euclidian_distance(c('b','b',3))
euclidian_distance <- function(x){
if(!is.numeric(x) | length(x) < 1){
print('Invalid input: should be a numeric vector of length higher than 1')
return (NaN)
}
return (distance <- sqrt( sum(x^2, na.rm = T)))
}
res <- euclidian_distance(c(1,2,3)) # test with some random values
res1 <- euclidian_distance(c(4,3,NA)) # test with NA values in the vector
res2 <- euclidian_distance(c(-1,-2,-3)) # test with negative values
res3 <- euclidian_distance(c('b','b',3))
manhatan_distance <- function(x){
if(!is.numeric(x) | length(x) < 1){
print('Invalid input: should be a numeric vector of length higher than 1')
return (NaN)
}
return (distance <- abs(x^2, na.rm = T))
}
res0 <- manhatan_distance(c(1,2,3)) # test with some random values
manhatan_distance <- function(x){
if(!is.numeric(x) | length(x) < 1){
print('Invalid input: should be a numeric vector of length higher than 1')
return (NaN)
}
return (distance <- abs(x^2))
}
res0 <- manhatan_distance(c(1,2,3)) # test with some random values
res1 <- manhatan_distance(c(4,3,NA)) # test with NA values in the vector
res2 <- manhatan_distance(c(-1,-2,-3)) # test with negative values
res3 <- manhatan_distance(c('b','b',3))
manhatan_distance <- function(x){
if(!is.numeric(x) | length(x) < 1){
print('Invalid input: should be a numeric vector of length higher than 1')
return (NaN)
}
return (distance <- abs(x^2))
}
res0 <- manhatan_distance(c(1,2,3)) # test with some random values
res1 <- manhatan_distance(c(4,3,NA)) # test with NA values in the vector
res2 <- manhatan_distance(c(-1,-2,-3)) # test with negative values
res3 <- manhatan_distance(c('b','b',3))
manhatan_distance <- function(x){
if(!is.numeric(x) | length(x) < 1){
print('Invalid input: should be a numeric vector of length at least equals to 1')
return (NaN)
}
return (distance <- abs(x^2))
}
res0 <- manhatan_distance(c(1,2,3)) # test with some random values
res1 <- manhatan_distance(c(4,3,NA)) # test with NA values in the vector
res2 <- manhatan_distance(c(-1,-2,-3)) # test with negative values
res3 <- manhatan_distance(c('b','b',3))
manhatan_distance <- function(x){
if(!is.numeric(x) | length(x) < 1){
print('Invalid input: should be a numeric vector of length at least equals to 1')
return (NaN)
}
return (distance <- sum(abs(x^2)))
}
res0 <- manhatan_distance(c(1,2,3)) # test with some random values
res1 <- manhatan_distance(c(4,3,NA)) # test with NA values in the vector
res2 <- manhatan_distance(c(-1,-2,-3)) # test with negative values
res3 <- manhatan_distance(c('b','b',3))
manhatan_distance <- function(x){
if(!is.numeric(x) | length(x) < 1){
print('Invalid input: should be a numeric vector of length at least equals to 1')
return (NaN)
}
return (distance <- sum(abs(x^2), na.rm=TRUE))
}
res0 <- manhatan_distance(c(1,2,3)) # test with some random values
res1 <- manhatan_distance(c(4,3,NA)) # test with NA values in the vector
res2 <- manhatan_distance(c(-1,-2,-3)) # test with negative values
res3 <- manhatan_distance(c('b','b',3))
manhatan_distance <- function(x){
if(!is.numeric(x) | length(x) < 1){
print('Invalid input: should be a numeric vector of length at least equals to 1')
return (NaN)
}
return (distance <- sum(abs(x), na.rm=TRUE))
}
res0 <- manhatan_distance(c(1,2,3)) # test with some random values
res1 <- manhatan_distance(c(4,3,NA)) # test with NA values in the vector
res2 <- manhatan_distance(c(-1,-2,-3)) # test with negative values
res3 <- manhatan_distance(c('b','b',3))
manhatan_distance <- function(x){
if(!is.numeric(x) | length(x) < 1){
print('Invalid input: should be a numeric vector of length at least equals to 1')
return (NaN)
}
return (distance <- sum(abs(x), na.rm=TRUE))
}
res0 <- manhatan_distance(c(1,2,3)) # test with some random values
res1 <- manhatan_distance(c(4,3,NA)) # test with NA values in the vector
res2 <- manhatan_distance(c(-1,-2,-3)) # test with negative values
res3 <- manhatan_distance(c('b','b',3))
# Loading the datasets
computersData <- read.table('ComputerData.txt', header = T)
summary(computersData)
# Loading the datasets
computersData <- read.table('ComputerData.txt', header = T)
carsData <- read.table('Cars2Data.txt', header = T)
summary(computersData)
summary(carsData)
# Loading the datasets
computersData <- read.table('ComputerData.txt', header = T)
carsData <- read.table('Cars2Data.txt', header = T)
carsData <- na.omit(carsData)
summary(computersData)
summary(carsData)
# Loading the datasets
computersData <- read.table('ComputerData.txt', header = T)
carsData <- read.table('Cars2Data.txt', header = T)
carsData <- na.omit(carsData)
summary(computersData)
summary(carsData)
